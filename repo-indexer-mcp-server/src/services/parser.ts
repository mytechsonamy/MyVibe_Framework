import * as crypto from "crypto";
import * as fs from "fs";
import * as path from "path";
import { glob } from "glob";
import {
  FileInfo,
  Symbol,
  Import,
  Export,
  Dependency,
  SupportedLanguage,
  SymbolKind,
  IndexConfig,
  DEFAULT_INDEX_CONFIG
} from "../types.js";

// File extension to language mapping
const EXTENSION_MAP: Record<string, SupportedLanguage> = {
  ".ts": "typescript",
  ".tsx": "typescript",
  ".js": "javascript",
  ".jsx": "javascript",
  ".mjs": "javascript",
  ".cjs": "javascript",
  ".py": "python",
  ".go": "go",
  ".java": "java"
};

// Generated file markers
const GENERATED_MARKERS = [
  "@generated",
  "DO NOT EDIT",
  "AUTO-GENERATED",
  "This file is auto-generated",
  "Generated by"
];

export class CodeParser {
  private repoPath: string;
  private config: IndexConfig;

  constructor(repoPath: string, config?: Partial<IndexConfig>) {
    this.repoPath = repoPath;
    this.config = {
      repoPath,
      includePatterns: config?.includePatterns || DEFAULT_INDEX_CONFIG.includePatterns!,
      excludePatterns: config?.excludePatterns || DEFAULT_INDEX_CONFIG.excludePatterns!,
      maxFileSize: config?.maxFileSize || DEFAULT_INDEX_CONFIG.maxFileSize!,
      languages: config?.languages || DEFAULT_INDEX_CONFIG.languages!,
      followSymlinks: config?.followSymlinks ?? DEFAULT_INDEX_CONFIG.followSymlinks!,
      includeNodeModules: config?.includeNodeModules ?? DEFAULT_INDEX_CONFIG.includeNodeModules!,
      includeGenerated: config?.includeGenerated ?? DEFAULT_INDEX_CONFIG.includeGenerated!
    };
  }

  // ============================================================================
  // FILE DISCOVERY
  // ============================================================================

  async discoverFiles(): Promise<string[]> {
    const allFiles: string[] = [];

    for (const pattern of this.config.includePatterns) {
      const files = await glob(pattern, {
        cwd: this.repoPath,
        ignore: this.config.excludePatterns,
        nodir: true,
        absolute: true,
        follow: this.config.followSymlinks
      });
      allFiles.push(...files);
    }

    // Remove duplicates
    return [...new Set(allFiles)];
  }

  // ============================================================================
  // FILE ANALYSIS
  // ============================================================================

  async analyzeFile(absolutePath: string): Promise<FileInfo | null> {
    try {
      const stats = fs.statSync(absolutePath);

      // Skip files that are too large
      if (stats.size > this.config.maxFileSize) {
        return null;
      }

      const ext = path.extname(absolutePath);
      const language = EXTENSION_MAP[ext] || null;

      // Skip unsupported languages
      if (language && !this.config.languages.includes(language)) {
        return null;
      }

      const content = fs.readFileSync(absolutePath, "utf-8");
      const hash = this.computeHash(content);
      const lineCount = content.split("\n").length;
      const isGenerated = this.isGeneratedFile(content);

      // Skip generated files if configured
      if (isGenerated && !this.config.includeGenerated) {
        return null;
      }

      return {
        path: absolutePath,
        relativePath: path.relative(this.repoPath, absolutePath),
        language,
        size: stats.size,
        hash,
        lastModified: stats.mtimeMs,
        lineCount,
        isGenerated
      };
    } catch (error) {
      console.error(`Error analyzing file ${absolutePath}:`, error);
      return null;
    }
  }

  private computeHash(content: string): string {
    return crypto.createHash("sha256").update(content).digest("hex");
  }

  private isGeneratedFile(content: string): boolean {
    const firstLines = content.slice(0, 1000); // Check first 1000 chars
    return GENERATED_MARKERS.some(marker =>
      firstLines.includes(marker)
    );
  }

  // ============================================================================
  // TYPESCRIPT/JAVASCRIPT PARSING
  // ============================================================================

  parseTypeScript(filePath: string, content: string): {
    symbols: Symbol[];
    imports: Import[];
    exports: Export[];
  } {
    const symbols: Symbol[] = [];
    const imports: Import[] = [];
    const exports: Export[] = [];

    const lines = content.split("\n");

    // Simple regex-based parsing (fast but less accurate than full AST)
    // In production, use tree-sitter or ts-morph for accuracy

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNum = i + 1;

      // Parse imports
      const importMatch = line.match(
        /^import\s+(?:type\s+)?(?:(\{[^}]+\})|(\*\s+as\s+\w+)|(\w+))(?:\s*,\s*(?:(\{[^}]+\})|(\w+)))?\s+from\s+['"]([^'"]+)['"]/
      );
      if (importMatch) {
        const importedSymbols: string[] = [];
        const isTypeOnly = line.includes("import type");

        // Named imports
        if (importMatch[1]) {
          const namedImports = importMatch[1].replace(/[{}]/g, "").split(",")
            .map(s => s.trim().split(/\s+as\s+/)[0])
            .filter(s => s);
          importedSymbols.push(...namedImports);
        }

        // Namespace import
        if (importMatch[2]) {
          importedSymbols.push("*");
        }

        // Default import
        if (importMatch[3]) {
          importedSymbols.push("default");
        }

        // Additional named imports
        if (importMatch[4]) {
          const namedImports = importMatch[4].replace(/[{}]/g, "").split(",")
            .map(s => s.trim().split(/\s+as\s+/)[0])
            .filter(s => s);
          importedSymbols.push(...namedImports);
        }

        imports.push({
          id: this.generateId(filePath, lineNum, "import"),
          filePath,
          importedFrom: importMatch[6],
          importedSymbols,
          isTypeOnly,
          isDynamic: false,
          line: lineNum
        });
      }

      // Parse dynamic imports
      const dynamicImportMatch = line.match(/import\s*\(\s*['"]([^'"]+)['"]\s*\)/);
      if (dynamicImportMatch) {
        imports.push({
          id: this.generateId(filePath, lineNum, "dynamic-import"),
          filePath,
          importedFrom: dynamicImportMatch[1],
          importedSymbols: ["*"],
          isTypeOnly: false,
          isDynamic: true,
          line: lineNum
        });
      }

      // Parse function declarations
      const funcMatch = line.match(
        /^(export\s+)?(async\s+)?function\s+(\w+)\s*(<[^>]*>)?\s*\(([^)]*)\)/
      );
      if (funcMatch) {
        const isExported = !!funcMatch[1];
        const isAsync = !!funcMatch[2];
        const name = funcMatch[3];
        const params = funcMatch[5];
        const signature = `${isAsync ? "async " : ""}function ${name}(${params})`;

        symbols.push(this.createSymbol(
          filePath, name, "function", lineNum, line.length,
          signature, isExported ? "named" : "none"
        ));
      }

      // Parse arrow functions (const/let/var)
      const arrowMatch = line.match(
        /^(export\s+)?(const|let|var)\s+(\w+)\s*(?::\s*[^=]+)?\s*=\s*(async\s+)?(\([^)]*\)|[^=])\s*=>/
      );
      if (arrowMatch) {
        const isExported = !!arrowMatch[1];
        const name = arrowMatch[3];

        symbols.push(this.createSymbol(
          filePath, name, "function", lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse class declarations
      const classMatch = line.match(
        /^(export\s+)?(abstract\s+)?class\s+(\w+)(?:\s+extends\s+(\w+))?(?:\s+implements\s+([^{]+))?/
      );
      if (classMatch) {
        const isExported = !!classMatch[1];
        const name = classMatch[3];

        symbols.push(this.createSymbol(
          filePath, name, "class", lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse interface declarations
      const interfaceMatch = line.match(
        /^(export\s+)?interface\s+(\w+)(?:<[^>]+>)?(?:\s+extends\s+[^{]+)?/
      );
      if (interfaceMatch) {
        const isExported = !!interfaceMatch[1];
        const name = interfaceMatch[2];

        symbols.push(this.createSymbol(
          filePath, name, "interface", lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse type aliases
      const typeMatch = line.match(/^(export\s+)?type\s+(\w+)(?:<[^>]+>)?\s*=/);
      if (typeMatch) {
        const isExported = !!typeMatch[1];
        const name = typeMatch[2];

        symbols.push(this.createSymbol(
          filePath, name, "type", lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse const/let/var declarations
      const varMatch = line.match(/^(export\s+)?(const|let|var)\s+(\w+)\s*(?::\s*[^=]+)?\s*=/);
      if (varMatch && !arrowMatch) { // Avoid duplicating arrow functions
        const isExported = !!varMatch[1];
        const name = varMatch[3];
        const kind = varMatch[2] === "const" ? "constant" : "variable";

        symbols.push(this.createSymbol(
          filePath, name, kind as SymbolKind, lineNum, line.length,
          undefined, isExported ? "named" : "none"
        ));
      }

      // Parse exports
      const exportDefaultMatch = line.match(/^export\s+default\s+(\w+)/);
      if (exportDefaultMatch) {
        exports.push({
          id: this.generateId(filePath, lineNum, "export-default"),
          filePath,
          exportedSymbol: exportDefaultMatch[1],
          isDefault: true,
          isTypeOnly: false,
          isReExport: false
        });
      }

      // Parse re-exports
      const reExportMatch = line.match(
        /^export\s+(?:type\s+)?(\{[^}]+\}|\*)\s+from\s+['"]([^'"]+)['"]/
      );
      if (reExportMatch) {
        const isTypeOnly = line.includes("export type");
        const exportedPart = reExportMatch[1];
        const from = reExportMatch[2];

        if (exportedPart === "*") {
          exports.push({
            id: this.generateId(filePath, lineNum, "reexport-all"),
            filePath,
            exportedSymbol: "*",
            isDefault: false,
            isTypeOnly,
            isReExport: true,
            reExportFrom: from
          });
        } else {
          const namedExports = exportedPart.replace(/[{}]/g, "").split(",")
            .map(s => s.trim())
            .filter(s => s);

          for (const exp of namedExports) {
            const [name, alias] = exp.split(/\s+as\s+/).map(s => s.trim());
            exports.push({
              id: this.generateId(filePath, lineNum, `reexport-${name}`),
              filePath,
              exportedSymbol: name,
              exportedAs: alias !== name ? alias : undefined,
              isDefault: false,
              isTypeOnly,
              isReExport: true,
              reExportFrom: from
            });
          }
        }
      }
    }

    return { symbols, imports, exports };
  }

  // ============================================================================
  // PYTHON PARSING
  // ============================================================================

  parsePython(filePath: string, content: string): {
    symbols: Symbol[];
    imports: Import[];
    exports: Export[];
  } {
    const symbols: Symbol[] = [];
    const imports: Import[] = [];
    const exports: Export[] = [];

    const lines = content.split("\n");

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNum = i + 1;

      // Parse import statements
      const importMatch = line.match(/^import\s+(\w+(?:\.\w+)*)/);
      if (importMatch) {
        imports.push({
          id: this.generateId(filePath, lineNum, "import"),
          filePath,
          importedFrom: importMatch[1],
          importedSymbols: ["*"],
          isTypeOnly: false,
          isDynamic: false,
          line: lineNum
        });
      }

      // Parse from ... import ...
      const fromImportMatch = line.match(
        /^from\s+(\w+(?:\.\w+)*)\s+import\s+(.+)/
      );
      if (fromImportMatch) {
        const module = fromImportMatch[1];
        const importedPart = fromImportMatch[2];
        const importedSymbols = importedPart === "*"
          ? ["*"]
          : importedPart.split(",").map(s => s.trim().split(/\s+as\s+/)[0]).filter(s => s);

        imports.push({
          id: this.generateId(filePath, lineNum, "from-import"),
          filePath,
          importedFrom: module,
          importedSymbols,
          isTypeOnly: false,
          isDynamic: false,
          line: lineNum
        });
      }

      // Parse function definitions
      const funcMatch = line.match(/^(async\s+)?def\s+(\w+)\s*\(([^)]*)\)/);
      if (funcMatch) {
        const name = funcMatch[2];
        const params = funcMatch[3];
        const isPrivate = name.startsWith("_");
        const signature = `def ${name}(${params})`;

        symbols.push(this.createSymbol(
          filePath, name, "function", lineNum, line.length,
          signature, isPrivate ? "none" : "named"
        ));
      }

      // Parse class definitions
      const classMatch = line.match(/^class\s+(\w+)(?:\s*\(([^)]*)\))?/);
      if (classMatch) {
        const name = classMatch[1];
        const isPrivate = name.startsWith("_");

        symbols.push(this.createSymbol(
          filePath, name, "class", lineNum, line.length,
          line.trim(), isPrivate ? "none" : "named"
        ));
      }

      // Parse top-level variable assignments
      const varMatch = line.match(/^(\w+)\s*(?::\s*[^=]+)?\s*=/);
      if (varMatch && !line.startsWith(" ") && !line.startsWith("\t")) {
        const name = varMatch[1];
        if (!name.startsWith("_") && name === name.toUpperCase()) {
          // Constants (ALL_CAPS)
          symbols.push(this.createSymbol(
            filePath, name, "constant", lineNum, line.length,
            undefined, "named"
          ));
        }
      }
    }

    return { symbols, imports, exports };
  }

  // ============================================================================
  // GO PARSING
  // ============================================================================

  parseGo(filePath: string, content: string): {
    symbols: Symbol[];
    imports: Import[];
    exports: Export[];
  } {
    const symbols: Symbol[] = [];
    const imports: Import[] = [];
    const exports: Export[] = [];

    const lines = content.split("\n");
    let inImportBlock = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNum = i + 1;

      // Track import block
      if (line.match(/^import\s*\(/)) {
        inImportBlock = true;
        continue;
      }
      if (inImportBlock && line.trim() === ")") {
        inImportBlock = false;
        continue;
      }

      // Parse imports
      const importMatch = line.match(/^\s*(?:(\w+)\s+)?["']([^"']+)["']/);
      if ((inImportBlock || line.startsWith("import")) && importMatch) {
        imports.push({
          id: this.generateId(filePath, lineNum, "import"),
          filePath,
          importedFrom: importMatch[2],
          importedSymbols: importMatch[1] ? [importMatch[1]] : ["*"],
          isTypeOnly: false,
          isDynamic: false,
          line: lineNum
        });
      }

      // Parse function declarations
      const funcMatch = line.match(/^func\s+(?:\(\w+\s+\*?\w+\)\s+)?(\w+)\s*\(/);
      if (funcMatch) {
        const name = funcMatch[1];
        const isExported = name[0] === name[0].toUpperCase();

        symbols.push(this.createSymbol(
          filePath, name, "function", lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse type declarations
      const typeMatch = line.match(/^type\s+(\w+)\s+(struct|interface)/);
      if (typeMatch) {
        const name = typeMatch[1];
        const kind = typeMatch[2] === "interface" ? "interface" : "class";
        const isExported = name[0] === name[0].toUpperCase();

        symbols.push(this.createSymbol(
          filePath, name, kind as SymbolKind, lineNum, line.length,
          line.trim(), isExported ? "named" : "none"
        ));
      }

      // Parse const/var declarations
      const constMatch = line.match(/^(const|var)\s+(\w+)/);
      if (constMatch) {
        const name = constMatch[2];
        const kind = constMatch[1] === "const" ? "constant" : "variable";
        const isExported = name[0] === name[0].toUpperCase();

        symbols.push(this.createSymbol(
          filePath, name, kind as SymbolKind, lineNum, line.length,
          undefined, isExported ? "named" : "none"
        ));
      }
    }

    return { symbols, imports, exports };
  }

  // ============================================================================
  // HELPER METHODS
  // ============================================================================

  private createSymbol(
    filePath: string,
    name: string,
    kind: SymbolKind,
    line: number,
    endColumn: number,
    signature?: string,
    exportType: "default" | "named" | "none" = "none"
  ): Symbol {
    return {
      id: this.generateId(filePath, line, name),
      name,
      kind,
      filePath,
      startLine: line,
      endLine: line, // Simplified - would need block detection for accurate end
      startColumn: 1,
      endColumn,
      signature,
      exportType,
      visibility: exportType !== "none" ? "public" : "private"
    };
  }

  private generateId(filePath: string, line: number, name: string): string {
    const input = `${filePath}:${line}:${name}`;
    return crypto.createHash("md5").update(input).digest("hex").slice(0, 16);
  }

  // Main parsing dispatcher
  parse(filePath: string, content: string, language: SupportedLanguage): {
    symbols: Symbol[];
    imports: Import[];
    exports: Export[];
  } {
    switch (language) {
      case "typescript":
      case "javascript":
        return this.parseTypeScript(filePath, content);
      case "python":
        return this.parsePython(filePath, content);
      case "go":
        return this.parseGo(filePath, content);
      default:
        return { symbols: [], imports: [], exports: [] };
    }
  }
}
